Creating a Finite-State Parser with Application Semantics
Owen Rambow	Srinivas Bangalore
University of Pennsylvania	AT&T Labs – Research
Philadelphia, PA 19104	Florham Park, NJ 07932
	USA	USA
Tahir Butt	Alexis Nasr	Richard Sproat
	Johns Hopkins University	Universit´e Paris 7	AT&T Labs – Research
Baltimore, MD 21218	75005 Paris	Florham Park, NJ 07932
USA	France	USA
rambow@unagi.cis.upenn.edu
Abstract
Parsli is a finite-state (FS) parser which can be tailored to the lexicon, syntax, and semantics of a particular application using a hand-editable declarative lexicon. The lexicon is defined in terms of a lexicalized Tree Adjoining Grammar, which is subsequently mapped to a FS representation. This approach gives the application designer better and easier control over the natural language understanding component than using an off-the-shelf parser. We present results using Parsli on an application that creates 3D-images from typed input.
1 Parsing and Application-Specific Semantics
One type of Natural Language Understanding (NLU) application is exemplified by the database access problem: the user may type in free source language text, but the NLU component must map this text to a fixed set of actions dictated by the underlying application program. We will call such NLU applications “application- semantic NLU”. Other examples of application- semantic NLU include interfaces to command- based applications (such as airline reservation systems), often in the guise of dialog systems.
Several general-purpose off-the-shelf (OTS) parsers have become widely available (Lin, 1994; Collins, 1997). For application-semantic NLU, it is possible to use such an OTS parser in conjunction with a post-processor which transfers the output of the parser (be it phrase structure or dependency) to the domain semantics. In addition to mapping the parser output to application semantics, the post-processor often must also “correct” the output of the parser: the parser may be tailored for a particular domain (such as
Wall Street Journal (WSJ) text), but the new domain presents linguistic constructions not found in the original domain (such as questions). It may also be the case that the OTS parser consistently misanalyzes certain lexemes because they do not occur in the OTS corpus, or occur there with different syntactic properties. While many of the parsers can be retrained, often an annotated corpus is not available in the application domain (since, for example, the application itself is still under development and there is not yet a user community). The process of retraining may also be quite complex in practice. A further disadvantage of this approach is that the post- processor must typically be written by hand, as procedural code. In addition, the application- semantic NLU may not even exploit the strengths of the OTS parser, because the NLU required for the application is not only different (questions), but generally simpler (the WSJ contains very long and syntactically complex sentences which are not likely to be found as input in interactive systems, including dialog systems).
This discussion suggests that we (i) need an easy way to specify application semantics for a parser and (ii) that we do not usually need the full power of a full recursive parser. In this paper, we suggest that application-semantic NLP may be better served by a lexicalized finite-state (FS) parser. We present PARSLI, a FS parser which can be tailored to the application semantics using a hand-editable declarative lexicon. This approach gives the application designer better and easier control over the NLU component. Furthermore, while the finite-state approach may not be sufficient for WSJ text (given its syntactic complexity), it is sufficient for most interactive systems, and the advantage in speed offered by FS approaches in more crucial in interactive appli-
